using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace TelnetNegotiationCore.SourceGenerators;

/// <summary>
/// Source generator that creates fast, reflection-free extension methods for enums.
/// Generates AllValues collections and IsDefined methods to replace Enum.GetValues() and Enum.IsDefined().
/// </summary>
[Generator]
public class EnumExtensionsGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver to find enum declarations
        context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not EnumSyntaxReceiver receiver)
            return;

        // Find Trigger and State enums in the compilation
        var triggerEnum = FindEnum(context, receiver, "Trigger");
        var stateEnum = FindEnum(context, receiver, "State");

        if (triggerEnum != null)
        {
            GenerateEnumExtensions(context, triggerEnum, "Trigger");
        }

        if (stateEnum != null)
        {
            GenerateEnumExtensions(context, stateEnum, "State", generateBadStateMethod: true);
        }
    }

    private INamedTypeSymbol? FindEnum(GeneratorExecutionContext context, EnumSyntaxReceiver receiver, string enumName)
    {
        foreach (var enumDecl in receiver.CandidateEnums)
        {
            var semanticModel = context.Compilation.GetSemanticModel(enumDecl.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(enumDecl) as INamedTypeSymbol;
            if (symbol?.Name == enumName && symbol.TypeKind == TypeKind.Enum)
            {
                return symbol;
            }
        }
        return null;
    }

    private void GenerateEnumExtensions(GeneratorExecutionContext context, INamedTypeSymbol enumSymbol, string enumName, bool generateBadStateMethod = false)
    {
        var namespaceName = enumSymbol.ContainingNamespace.ToDisplayString();
        var values = enumSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.IsConst)
            .ToList();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Collections.Immutable;");
        sb.AppendLine($"using {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("namespace TelnetNegotiationCore.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated extension methods for {enumName} enum - replaces reflection with compile-time code.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {enumName}Extensions");
        sb.AppendLine("{");

        // Generate AllValues property
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// All {enumName} values (generated at compile time).");
        sb.AppendLine($"    /// Replaces: Enum.GetValues(typeof({enumName}))");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static readonly ImmutableHashSet<{enumName}> AllValues = ImmutableHashSet.Create(");

        for (int i = 0; i < values.Count; i++)
        {
            var value = values[i];
            var comma = i < values.Count - 1 ? "," : "";
            sb.AppendLine($"        {enumName}.{value.Name}{comma}");
        }

        sb.AppendLine("    );");
        sb.AppendLine();

        // Generate IsDefined method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Fast validation without reflection.");
        sb.AppendLine($"    /// Replaces: Enum.IsDefined(typeof({enumName}), value)");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static bool IsDefined(short value) => value switch");
        sb.AppendLine("    {");

        // Deduplicate by value to avoid unreachable patterns
        var seenValues = new HashSet<object>();
        foreach (var value in values)
        {
            var constantValue = value.ConstantValue;
            if (constantValue != null && seenValues.Add(constantValue))
            {
                sb.AppendLine($"        {constantValue} => true,  // {value.Name}");
            }
        }

        sb.AppendLine("        _ => false");
        sb.AppendLine("    };");

        // Generate GetBadState method if requested (only for State enum)
        if (generateBadStateMethod)
        {
            sb.AppendLine();
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Get 'Bad' state variant for error handling.");
            sb.AppendLine("    /// Replaces: (State)Enum.Parse(typeof(State), $\"Bad{state}\")");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static State GetBadState(State state) => state switch");
            sb.AppendLine("    {");

            // Find all "Bad" states by looking for enum values that start with "Bad"
            var badStateMappings = new List<(string normalState, string badState)>();
            foreach (var value in values)
            {
                if (value.Name.StartsWith("Bad") && value.Name.Length > 3)
                {
                    var normalStateName = value.Name.Substring(3); // Remove "Bad" prefix
                    // Check if the normal state exists
                    if (values.Any(v => v.Name == normalStateName))
                    {
                        badStateMappings.Add((normalStateName, value.Name));
                    }
                }
            }

            foreach (var (normalState, badState) in badStateMappings)
            {
                sb.AppendLine($"        State.{normalState} => State.{badState},");
            }

            sb.AppendLine("        _ => throw new ArgumentException($\"No Bad state exists for {state}\", nameof(state))");
            sb.AppendLine("    };");
        }

        sb.AppendLine("}");

        var sourceText = SourceText.From(sb.ToString(), Encoding.UTF8);
        context.AddSource($"{enumName}Extensions.g.cs", sourceText);
    }
}

/// <summary>
/// Syntax receiver that collects enum declarations
/// </summary>
internal class EnumSyntaxReceiver : ISyntaxReceiver
{
    public List<EnumDeclarationSyntax> CandidateEnums { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // Look for enum declarations
        if (syntaxNode is EnumDeclarationSyntax enumDecl)
        {
            // Look for Trigger or State enums
            if (enumDecl.Identifier.Text == "Trigger" || enumDecl.Identifier.Text == "State")
            {
                CandidateEnums.Add(enumDecl);
            }
        }
    }
}
