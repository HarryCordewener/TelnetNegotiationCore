using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace TelnetNegotiationCore.SourceGenerators;

/// <summary>
/// Source generator that creates compile-time property accessors for MSSPConfig
/// to replace runtime reflection with generated code.
/// </summary>
[Generator]
public class MSSPConfigGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver to find MSSPConfig class
        context.RegisterForSyntaxNotifications(() => new MSSPSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not MSSPSyntaxReceiver receiver)
            return;

        // Find MSSPConfig class in the compilation
        INamedTypeSymbol? msspConfigClass = null;
        foreach (var classDecl in receiver.CandidateClasses)
        {
            var semanticModel = context.Compilation.GetSemanticModel(classDecl.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (symbol?.Name == "MSSPConfig")
            {
                msspConfigClass = symbol;
                break;
            }
        }

        if (msspConfigClass == null)
            return; // MSSPConfig not found in this compilation

        // Extract properties with [Name] attribute
        var properties = ExtractMSSPProperties(msspConfigClass);

        if (properties.Count == 0)
            return;

        // Generate the accessor class
        var sourceText = GenerateMSSPAccessor(properties);

        // Add the generated source to the compilation
        context.AddSource("MSSPConfigAccessor.g.cs", SourceText.From(sourceText, Encoding.UTF8));
    }

    private List<MSSPPropertyInfo> ExtractMSSPProperties(INamedTypeSymbol msspConfigClass)
    {
        var properties = new List<MSSPPropertyInfo>();

        foreach (var member in msspConfigClass.GetMembers().OfType<IPropertySymbol>())
        {
            // Find [Name] attribute
            var nameAttribute = member.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "NameAttribute");

            if (nameAttribute == null)
                continue;

            // Extract attribute arguments
            var msspName = nameAttribute.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? member.Name;
            
            var officialAttribute = member.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "OfficialAttribute");
            var isOfficial = officialAttribute?.ConstructorArguments.FirstOrDefault().Value as bool? ?? false;

            properties.Add(new MSSPPropertyInfo(
                propertyName: member.Name,
                msspName: msspName,
                propertyType: member.Type.ToDisplayString(),
                isOfficial: isOfficial
            ));
        }

        return properties;
    }

    private string GenerateMSSPAccessor(List<MSSPPropertyInfo> properties)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using TelnetNegotiationCore.Models;");
        sb.AppendLine();
        sb.AppendLine("namespace TelnetNegotiationCore.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated MSSP configuration accessor - replaces reflection with compile-time code.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class MSSPConfigAccessor");
        sb.AppendLine("{");

        // Generate property map
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Pre-computed mapping of MSSP variable names to property metadata.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static readonly IReadOnlyDictionary<string, MSSPPropertyMetadata> PropertyMap = new Dictionary<string, MSSPPropertyMetadata>");
        sb.AppendLine("    {");
        
        foreach (var prop in properties)
        {
            sb.AppendLine($"        [\"{prop.MSSPName.ToUpperInvariant()}\"] = new(\"{prop.PropertyName}\", \"{prop.PropertyType}\", {prop.IsOfficial.ToString().ToLowerInvariant()}),");
        }
        
        sb.AppendLine("    };");
        sb.AppendLine();

        // Generate TrySetProperty method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Sets a property value by MSSP variable name using generated code (zero reflection).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static bool TrySetProperty(MSSPConfig config, string msspVariableName, object? value)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (config == null) throw new ArgumentNullException(nameof(config));");
        sb.AppendLine();
        sb.AppendLine("        return msspVariableName.ToUpperInvariant() switch");
        sb.AppendLine("        {");
        
        foreach (var prop in properties)
        {
            sb.AppendLine($"            \"{prop.MSSPName.ToUpperInvariant()}\" => TrySet_{prop.PropertyName}(config, value),");
        }
        
        sb.AppendLine("            _ => false");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate individual setter methods
        foreach (var prop in properties)
        {
            GenerateSetterMethod(sb, prop);
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Generate metadata record
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Metadata about an MSSP property.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public record MSSPPropertyMetadata(string PropertyName, string PropertyType, bool IsOfficial);");

        return sb.ToString();
    }

    private void GenerateSetterMethod(StringBuilder sb, MSSPPropertyInfo prop)
    {
        sb.AppendLine($"    private static bool TrySet_{prop.PropertyName}(MSSPConfig config, object? value)");
        sb.AppendLine("    {");

        // Generate type-specific conversion logic
        if (prop.PropertyType == "string" || prop.PropertyType == "string?")
        {
            sb.AppendLine("        if (value is string str) { config." + prop.PropertyName + " = str; return true; }");
        }
        else if (prop.PropertyType == "int" || prop.PropertyType == "int?")
        {
            sb.AppendLine("        if (value is int i) { config." + prop.PropertyName + " = i; return true; }");
            sb.AppendLine("        if (value is string s && int.TryParse(s, out var parsed)) { config." + prop.PropertyName + " = parsed; return true; }");
        }
        else if (prop.PropertyType == "bool" || prop.PropertyType == "bool?")
        {
            sb.AppendLine("        if (value is bool b) { config." + prop.PropertyName + " = b; return true; }");
            sb.AppendLine("        if (value is string s && bool.TryParse(s, out var parsed)) { config." + prop.PropertyName + " = parsed; return true; }");
        }
        else if (prop.PropertyType.Contains("IEnumerable"))
        {
            sb.AppendLine("        if (value is System.Collections.Generic.IEnumerable<string> enumerable) { config." + prop.PropertyName + " = enumerable; return true; }");
        }
        else
        {
            sb.AppendLine("        // Type not supported for auto-generation: " + prop.PropertyType);
        }

        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private class MSSPPropertyInfo
    {
        public string PropertyName { get; }
        public string MSSPName { get; }
        public string PropertyType { get; }
        public bool IsOfficial { get; }

        public MSSPPropertyInfo(string propertyName, string msspName, string propertyType, bool isOfficial)
        {
            PropertyName = propertyName;
            MSSPName = msspName;
            PropertyType = propertyType;
            IsOfficial = isOfficial;
        }
    }
}

/// <summary>
/// Syntax receiver that collects candidate class declarations
/// </summary>
internal class MSSPSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // Look for classes named MSSPConfig
        if (syntaxNode is ClassDeclarationSyntax classDecl 
            && classDecl.Identifier.Text == "MSSPConfig")
        {
            CandidateClasses.Add(classDecl);
        }
    }
}
